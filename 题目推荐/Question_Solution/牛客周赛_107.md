# 牛客周赛 Round 107

竞赛地址: https://ac.nowcoder.com/acm/contest/116343

### A.小红打怪(贪心)

贪心，只选最大的攻击。计算时记得向上取整。

```c++
void solve()
{
    int a, l, r;
    cin >> a >> l >> r;
    cout << (a + r - 1) / r << endl;
}
```

### B.小红砍怪(模拟)

记录每个相同数字出现的索引，取最大值。

```c++
void solve()
{
    int n;
    cin >> n;
    vector<vector<int>> a(n+1, vector<int>());
    for(int i = 0; i < 2 * n; i++)
    {
        int x;
        cin >> x;
        a[x].push_back(i);
    }
    int mx = 0;
    for(int i = 1; i <= n; i++)
    {
        mx = max(mx, a[i][1] - a[i][0] + 1);
    }
    cout << mx << endl;
}
```

### C.小红加强打怪(二分)

最开始想到可以把每个值都存起来，因为小红的总攻击相当于是一个等差数列，我们就可以直接求第一个大于怪物血量的攻击次数。但是这样的内存使用太大了。考虑使用二分，直接二分我们需要的那个答案次数，这样的时间复杂是O(nlogn)，不会超时。
```c++
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

int64 attacks(unsigned long long a){
    long long l = 0, r = 1000000000LL;
    while(l < r){
        long long m = (l + r) >> 1;
        long long sum = (long long)m * (m + 1) / 2;
        if(sum >= a) r = m;
        else l = m + 1;
    }
    return l;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    unsigned long long x;
    long long ans = 0;
    for(int i = 0; i < n; ++i){
        cin >> x;
        ans += attacks(x);
    }
    cout << ans << "\n";
    return 0;
}

```

### D.小红走迷宫(搜索)

考验搜索的基本功，只是添加了一个限制条件。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2e5+10;
int n, m, x;
vector<bool> vis(N);
set<int> xx;
vector<int> e[N];
vector<int> ans;
void bfs()
{
    queue<int> q;
    q.push(1);
    vis[1] = true;
    ans.push_back(1);
    while(!q.empty())
    {
        int v = q.front();
        q.pop();
        for(auto u : e[v])
        {
            if(!vis[u] && !xx.count(u))
            {
                q.push(u);
                vis[u] = true;
                ans.push_back(u);
            }
        }
    }
}
void solve()
{
    cin >> n >> m >> x;
    for(int i = 0; i < x; i++)
    {
        int y;
        cin >> y;
        xx.insert(y);
    }
    for(int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    bfs();
    sort(ans.begin(), ans.end());
    for(int i = 0; i < ans.size(); i++)
    {
        cout << ans[i] << " ";
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### E.小笨的刷怪笼(构造)

首先注意到每个怪物的血量至少为1，我们考虑构造剩余的a-n血量的分配。

什么情况下无法找可行的方案？

当k小于消灭所有怪物所需要的最小操作次数，或者大于最大操作次数。

如何构造？

小红会按照最优的方案执行，所以最优的操作是每次减少两滴血量，也就是选择攻击相邻的两个怪物。

如何最大化/最小化需要的操作次数呢？

考虑操作数组边缘的血量，对于第一个怪物，我们无法通过攻击它前面的怪物来减少第一个怪物的血量，所以，我们把剩余的血量直接分配到第一个怪物上，这是操作次数最大化。

同样的，最小化次数，只需要平均分配血量在第一个和第二个怪物上。

只要k位于最大和最小之间，我们就可以构造出来。

```c++
void solve()
{
    int n, a, k;
    cin >> n >> a >> k;
    if(k < (n + 1) / 2 + (a - n + 1) / 2 || k > (n + 1) / 2 + (a - n))
    {
        //k不位于区间内
        cout << -1 << endl;
        return;
    }
    if(n == 1)
    {
        cout << a << endl;
        return;
    }
    //构造
    vector<int> vec(n, 1);
    k -= (n + 1) / 2;
    a -= n;
    vec[0] += k;
    vec[1] += a - k;
    for(int i = 0; i < n; i++)
    {
        cout << vec[i] << " ";
    }
}
```

### F.毒苯(离线bfs/优先队列)

首先容易想到对于每次询问，我们可以直接搜索一次，但是q可能很大，必定会超时。

我们可以观察到，对于每个询问的x，大的x总是比小的x消灭的元素更多，即 **更大的x所包含的范围，肯定包含了更小的x所包含的范围**。

所以对于每个询问，我们可以将x的大小排序，从小的x开始bfs。

那将bfs队列中的元素从小到大排序，这样能够扩展出来的x必然是这个有序bfs队列的一个前缀。

```c++
    #include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};
struct Node
{
    int val, x, y;

    bool operator<(const Node & n) const
    {
        return val > n.val;
    }
};

void solve()
{
    int n, m, q;
    cin >> n >> m >> q;
    vector<vector<int>> v(n + 1, vector<int>(m + 1));
    vector<vector<bool>> vis(n + 1, vector<bool>(m + 1, false));
    vector<pair<int, int>> que(q + 1);
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            cin >> v[i][j];
        }
    }
    for(int i = 1; i <= q; i++)
    {
        int qq;
        cin >> qq;
        que[i].first = qq;
        que[i].second = i;
    }
    sort(que.begin() + 1, que.end());
    priority_queue<Node> pq;
    for(int j = 1; j <= m; j++)
    {
        pq.push({v[1][j], 1, j});
    }

    int sum = 0;
    vector<int> ans(q+1);
    for(int i = 1; i <= q; i++)
    {
        auto [cur, id] = que[i];
        while(pq.size() && pq.top().val <= cur)
        {
            int X = pq.top().x;
            int Y = pq.top().y;
            pq.pop();
            if(vis[X][Y]) continue;
            vis[X][Y] = true;
            sum++;
            for(int k = 0; k < 4; k++)
            {
                int nx = X + dx[k];
                int ny = Y + dy[k];
                if(nx < 1 || nx > n || ny < 1 || ny > m || vis[nx][ny]) continue;
                pq.push({v[nx][ny], nx, ny});
            }
        }
        ans[id] = sum;
    }

    for(int i = 1; i <= q; i++)
    {
        cout << ans[i] << endl;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### End