# 牛客周赛 Round 109

竞赛地址：https://ac.nowcoder.com/acm/contest/116945

### A.小红的直角三角形

题目限定了输入的点的位置位于坐标轴上，所以我们只需要这两个点的$(x,y)$互不相同，即$x_1 \ne x_2, y_1 \ne y_2$。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    if((x1 == x2) || (y1 == y2))
    {
        cout << "No\n";
        return;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### B.小红的好点对

注意到输入的$n\le100$，我们完全可以暴力的求解，对于每个点，我们暴力的去找符合条件的好点对，这样每个好点对都被计算了两次，我们输出的时候对答案除以2即可。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    int n;
    cin >> n;
    vector<int> x(n), y(n);
    for(int i = 0; i < n; i++)
    {
        cin >> x[i] >> y[i];
    }
    int ans = 0;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < n; j++)
        {
            if(i != j)
            {
                double a;
                a = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));
                if(a == 1)
                {
                    ans++;
                }
            }
        }
    }
    cout << ans / 2 << endl;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### C.小红的整数三角形

注意到，两个点所构成的线是三角形的一条边。当这两个点$x_1 = x_2$ 或者 $y_1= y_2$时，这个时候我们可以直接构造第三个点，使得$x_3 = x1,y_3 = y_1+2$ 或者 $x_3 = x_1 + 2, y_3 = y_1$。这样三角形的高就为2了，乘上底也必然为偶数。

当$x_1 \ne x_2,y_1 \ne y_2$时我们就需要考虑以输入的这两个点为腰的等腰三角形。

我们以$x_1$为横坐标较小的那个点，$y_3 = y_2，x_3 = x_2 - (x_2 - x_1)$，这样我们就构造出了一个等腰三角形，并且面积肯定为偶数。因为$d=(x_2 - x_1)，2d$必定是个偶数，所以$S = 2d\times(|y_1 - y_2|)$也必定是个偶数。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    ll x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;

    ll x3, y3;
    if(x1 == x2)
    {
        x3 = x1 + 2;
        y3 = y1;
    }
    else if(y1 == y2)
    {
        x3 = x1;
        y3 = y1 + 2;
    }
    else
    {
        if(x1 > x2)
        {
            swap(x1, x2);
            swap(y1, y2);
        }
        x3 = x2 - 2*(x2 - x1);
        y3 = y2;
    }
    cout << x3 << " " << y3 << endl;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### D.小红的马

首先想到遍历马的位置，但是这样很难实现。

数学老师说过："正难则反"。

我们可以遍历小兵的位置，每个小兵可以被马攻击到的位置也只有8个，所以我们可以直接遍历小兵，把每个可以被攻击的位置++，然后遍历存下来的位置，直接输出最大(即哪个位置被最多的小兵包含到)的即可。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    int n;
    cin >> n;
    vector<vector<int>> go = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};
    vector<int> x(n), y(n);
    for(int i = 0; i < n; i++)
    {
        cin >> x[i] >> y[i];
    }
    map<pair<int, int>, int> mp;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < 8; j++)
        {
            int dx = x[i] + go[j][0];
            int dy = y[i] + go[j][1];
            mp[{dx, dy}]++;
        }
    }
    pair<int, int> ans;
    int mx = 0;
    for(auto z : mp)
    {
        if(z.second > mx && z.first.first > 0 && z.first.second > 0)
        {
            mx = z.second;
            ans = z.first;
        }
    }
    cout << ans.first << " " << ans.second << endl;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### E.小红的好矩形

注意是长**或**宽为1，我们只关心一个矩形的两条较短的那一条边。

经典的计数问题，对于每个合法的矩形，我们的摆放方式只能是短的一边平行于x，或者平行于y(斜着放最短的边都是$\sqrt{2}$)。

考虑枚举短边数量，将每个点按照x大小排序，枚举短边平行于y轴的矩形。

如何枚举？

我们可以枚举矩形的右下角的点(x,y)，只有当(x,y+1)的点存在时，我们才可能使用前面的同样平行于y轴的线段，构成一个合法的矩形。

短边平行于x轴的同理。

最后注意正方形的情况，每个正方形都被计算了两次，记得减去正方形的数量。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
struct point
{
    int x, y;
};
void solve()
{
    int n;
    cin >> n;
    vector<point> a(n);
    map<pair<int, int>, int> cnt;
    for(int i = 0; i < n; i++)
    {
        cin >> a[i].x >> a[i].y;
        cnt[{a[i].x, a[i].y}]++;
    }
    sort(a.begin(), a.end(), [&](auto X, auto Y) -> bool {
        return X.x < Y.x;
    });
    ll ans = 0;
    map<int, int> mpy;
    for(int i = 0; i < n; i++)
    {
        if(cnt.count({a[i].x,a[i].y+1}))
        {
            ans += mpy[a[i].y];
            mpy[a[i].y]++;
        }
    }

    sort(a.begin(), a.end(), [&](auto X, auto Y) -> bool {
        return X.y < Y.y;
    });

    
    map<int, int> mpx;
    for(int i = 0; i < n; i++)
    {
        if(cnt.count({a[i].x+1, a[i].y}))
        {
            ans += mpx[a[i].x];
            mpx[a[i].x]++;
        }
    }
    ll c = 0;
    for(int i = 0; i < n; i++)
    {
        if(cnt.count({a[i].x + 1, a[i].y}) && cnt.count({a[i].x, a[i].y + 1}) && cnt.count({a[i].x+1, a[i].y+1}))
        {
            c++;
        }
    }
    cout << ans - c << endl;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### F.小红的线下查询(树状数组/离散化/离线)

首先观察题目所给的公式，$y = x + k_1, y = -x + k2$，要求在这两个直线下方，所以变为了$y < x + k_1, y < -x + k_2$，化简后: $x - y > -k_1, x + y < k_2$。

等一下，如果我们把$-k_1$看成y轴，把$k_2$看成x轴，问题是不是就转化为了：对于每一个$-k_1,k_2$求这个坐标系右下角的点有多少个。

我们应该如何去找这些点呢？

介绍一种数据结构：树状数组。

树状数组是一种支持 **单点修改** 和 **区间查询** 的，代码量小的数据结构。

事实上，树状数组能解决的问题是线段树能解决的问题的子集：树状数组能做的，线段树一定能做；线段树能做的，树状数组不一定可以。然而，树状数组的代码要远比线段树短，时间效率常数也更小，因此仍有学习价值。

具体的介绍以及实现参考：https://oi-wiki.org/ds/fenwick/

回到我们这个题目上，我们可以把每次的询问离散化，按照$k_1$从小到大排序(可以想象为一条竖线，从左到右的扫过去，被扫过的点自然就是不符合题意的)，然后每次询问，我们就直接查询$k_2$的位置即可。

注意：输入的点很大，我们需要离散化一下才可以使用树状数组。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 树状数组模板
class BIT{
public:
    BIT(ll size) : size_(size), tree_(size + 1, 0) {}

    //单点更新
    void update(ll index, ll delta)
    {
        // lowbit: i & -i
        for(ll i = index + 1; i <= size_; i += (i & -i))
        {
            tree_[i] += delta;
        }
    }

    //单点查询(前缀和)
    ll query(ll index)
    {
        ll sum = 0;
        for(ll i = index + 1; i > 0; i -= (i & -i))
        {
            sum += tree_[i];
        }
        return sum;
    }

    //区间查询
    ll queryRange(ll left, ll right)
    {
        return query(right) - query(left - 1);
    }
private:
    ll size_;
    vector<ll> tree_;
};

struct Query{
    ll  k1, k2, id;

    bool operator<(const Query & q) const{
        return k1 < q.k1;
    }
};
void solve()
{
    ll n, q;
    cin >> n >> q;
    vector<pair<ll, ll>> a(n + 1);
    vector<ll> v;
    map<ll, ll> mp;

    // y < x + k1 => x - y > -k1
    // y < -x + k2 => x + y < k2
    for(ll i = 1, x, y; i <= n; i++)
    {
        cin >> x >> y;
        //转化坐标
        ll X = x - y;
        ll Y = x + y;
        a[i] = {X, Y};
        v.emplace_back(X);
        v.emplace_back(Y);
    }

    vector<Query> Q(q);
    for(ll i = 0; i < q; i++)
    {
        cin >> Q[i].k1 >> Q[i].k2;
        Q[i].id = i;
        Q[i].k1 *= -1;
        v.emplace_back(Q[i].k1);
        v.emplace_back(Q[i].k2);
    }

    //离散化
    sort(v.begin(), v.end());
    ll idx = 1;
    for(ll i = 1; i < v.size(); i++)
    {
        if(i > 0 && v[i] > v[i-1])
        {
            idx++;
        }
        mp[v[i]] = idx;
    }

    //使用离散化后的值
    for(ll i = 1; i <= n; i++)
    {
        auto & [x, y] = a[i];
        x = mp[x];
        y = mp[y];
    }
    for(auto &[k1, k2, _] : Q)
    {
        k1 = mp[k1];
        k2 = mp[k2];
    }

    BIT bit((n + q) * 2 + 1);
    for(ll i = 1; i <= n; i++)
    {
        auto [x, y] = a[i];
        //本质上y是(x + y),需要小于k2
        bit.update(y, 1);
    }
    sort(a.begin() + 1, a.end());
    sort(Q.begin(), Q.end());

    vector<ll> ans(q);
    ll i = 1;
    for(auto &[k1, k2, id] : Q)
    {
        while(i <= n && a[i].first <= k1)
        {
            //不符合的
            bit.update(a[i].second, -1);
            i++;
        }
        ans[id] = bit.query(k2 - 1);
    }

    for(ll i = 0; i < q; i++)
    {
        cout << ans[i] << endl;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    ll t = 1;
    //cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### End
***