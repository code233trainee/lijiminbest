# 牛客小白月赛 Round 120(A~D)

竞赛地址: https://ac.nowcoder.com/acm/contest/116657

### A.牛牛的串串

把所有的字符都存起来，然后从小到大排序判断即可

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    int n;
    string s;
    cin >> n >> s;
    vector<int> a(26);
    for(int i = 0; i < n; i++)
    {
        a[s[i]-'a']++;
    }
    vector<int> ans;
    for(int i = 0; i < 26; i++)
    {
        if(a[i] != 0)
        {
            ans.push_back(a[i]);
        }
    }
    sort(ans.begin(), ans.end());
    for(int i = 1; i < ans.size(); i++)
    {
        if(ans[i] != ans[i-1] + 1)
        {
            cout << "NO\n";
            return;
        }
    }
    cout << "YES\n";
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### B.牛牛的合数

> 异或运算规则：相异为1 相同为0
> 
> 合数：一个大于 1 且不是质数的正整数被称作合数(注意：2不是合数)

注意 $y$ 的范围: $1\le y < x$

我们可以很自然的观察到大于2的偶数都是合数，$x = 1,2,3$都是无解的情况

$x = 1$, 显然没有合适的$y$

$x = 2$, $2 \oplus 1 = 3$ 不满足题意

$x = 3$, $3 \oplus 1,2 = 2,1$ 不满足题意(注意：2不是合数)

我们回到二进制的视角上：

对于一个大于2的偶数：0100，0110，111000，110100...

我们只需要异或上2就可以了，因为这样不会改变x的奇偶性

大于3的奇数只需要异或上1就可以了

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve() {
    int x;
    cin >> x;
    if (x == 1 || x == 2 || x == 3) 
    {
        cout << -1 << '\n';
        return;
    }
    if (x % 2 == 1) 
    {
        cout << 1 << '\n';
    }
    else
    {
        cout << 2 << '\n';
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}

```

### C.牛牛的排列

注意到，一个排列如果从小到大排列，那么它必然是奇偶交替的

而奇数和偶数的最大公因数为1

所以当数组长度为奇数时，我们直接按序输出这个排列就好

当数组长度为偶数时，我们需要考虑构造一个相邻元素gcd为2，而且不影响其他相邻元素gcd大小(为1)的数组

考虑1 3 2 4，这样如果数组长度大于4，后面的元素也可以直接按序输出

特别的，n = 2时无解

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    int n;
    cin >> n;
    if(n % 2 == 1)
    {
        for(int i = 1; i <= n; i++)
        {
            cout << i << " ";
        }
        cout << endl;
    }
    else
    {
        if(n == 2)
        {
            cout << -1 << endl;
        }
        else
        {
            cout << "1 3 2 4 ";
            for(int i = 5; i <= n; i++)
            {
                cout << i << " ";
            }
            cout << endl;
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

### D.牛牛的子序列

对于两个序列我们可以找到不可能的情况是，当a中的连续的序列数量大于b中对应的连续序列的数量就不可能构造出来

现在我们看可以构造的情况，当a中的元素x出现了一次，b中的元素出现了k次，我们相当于是找到$2^{t} \ge k$ 求最小的t，公式就转化为了求$\left \lceil  \log_{2}{k} \right \rceil$

但是对于a中的元素不为1的情况，我们可以看成将a中的每个元素都分配一块需要增长的数量，比如a中有3个元素，对应的b中有6个元素，那么每个元素需要增长 $\frac{3}{6}=2$ 也就是求$\left\lceil\log_{2}{2}\right\rceil$也就是1

做法就是，我们直接遍历这两个数组，一直取最大值就好了

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
void solve()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n), b(m);
    for(int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    for(int i = 0; i < m; i++)
    {
        cin >> b[i];
    }
    int pa = 0, pb = 0;
    int ans = 0;
    while(pa < n)
    {
        int val = a[pa];

        int ga = 0;
        while(pa + ga < n && a[pa + ga] == val) ga++;

        int gb = 0;
        while(pb + gb < m && b[pb + gb] == val) gb++;

        if(gb < ga)
        {
            //a中的元素个数大于b中的元素个数
            cout << -1 << endl;
            return;
        }

        int per = (gb + ga - 1) / ga;
        int need = 0;
        if(per <= 1)
        {
            need = 0;
        }
        else
        {
            need = (int)ceil(log2((double)per));
        }

        ans = max(ans, need);

        pa = pa + ga;
        pb = pb + gb;
    }
    if(pb != m)
    {
        //剩余元素没有遍历完
        cout << -1 << endl;
    }
    else
    {
        cout << ans << endl;
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t = 1;
    cin >> t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```
### End
***